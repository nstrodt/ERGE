(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["ERGE`"]

Unprotect@@Names["ERGE`*"];
ClearAll@@Names["ERGE`*"];

$ERGEMainVersion=0;
$ERGEVersion=2;
$ERGEBuiltVersion=1;

$ERGEVersionNumber=ToString@$ERGEMainVersion~~"."~~ToString@$ERGEVersion~~"."~~ToString@$ERGEBuiltVersion;

Print["\nERGE package loaded.\n\nVersion "<>$ERGEVersionNumber<>".\n\nCopyright (C) 2016-2017, Nils Strodthoff.\n"]


doEDSE::usage="Derives the symbolic DSE for a given n-point function in a specified theory.
Parameters:
fields: a list of the form {{bosons},{fermions}} which can/ have to contain again sublists of two elements in case of fermionic fields/complex fields. e.g. {{phi}{{psi,psib}}} for a Yukawa theory
interactions: list of interaction terms to be considered (including non-diagonal propagators) permutations are automatically considered e.g. {{phi,phi,phi},{phi,phi,phi,phi},{phi,psi,psib}} for a Yukawa theory with cubic and quartic bosonic interactions.
Derivatives: specifies the npt function for which the flow equation should be derived e.g. {phi,phi} for a bosonic propagator. All derivatives are understood as left derivatives with the rightmost entry acting first unless DoFunInput==True

Options:
DoFunOutput->True/False convert to DoFun-compatible syntax and conventions (op function, vertex definition)
DoFunInput->True/False derivatives in DoFun compatible form (left/right derivatives for afermions/fermions; leftmost derivative acts first)
BareVertices->{} allows to pass a list of bare vertices (by default Interactions will be used)";
doEMAGIC::usage="Derives a generalized DSE using the given equation (and derivatives of it)
fields: a list of the form {{bosons},{fermions}} which can/ have to contain again sublists of two elements in case of fermionic fields/complex fields. e.g. {{phi}{{psi,psib}}} for a Yukawa theory
interactions: list of interaction terms to be considered (including non-diagonal propagators) permutations are automatically considered e.g. {{phi,phi,phi},{phi,phi,phi,phi},{phi,psi,psib}} for a Yukawa theory with cubic and quartic bosonic interactions.
Derivatives: specifies the npt function for which the flow equation should be derived e.g. {phi,phi} for a bosonic propagator. All derivatives are understood as left derivatives with the rightmost entry acting first
Eqn: generating equation; append x to fieldnames which should be substituted by G*der+phi e.g. phi->phix
Notation for Eqn: TrMMA[...], allowed symbols: field[index], fieldx[index], Gamma0[field1[index1],...], Der[field[index]]; use iy1,iy2,... for dummy indices, external indices should be denoted by i1,i2,...
DOEDSE->True/False:set to true if called from doEDSE (required for DoFun conversion)
";
doERGE::usage="Derives the symbolic flow equation for a given n-point function in a specified theory.
Parameters:
fields: a list of the form {{bosons},{fermions}} which can/ have to contain again sublists of two elements in case of fermionic fields/complex fields. e.g. {{phi}{{psi,psib}}} for a Yukawa theory
interactions: list of interaction terms to be considered (including non-diagonal propagators) permutations are automatically considered e.g. {{phi,phi,phi},{phi,phi,phi,phi},{phi,psi,psib}} for a Yukawa theory with cubic and quartic bosonic interactions.
Derivatives: specifies the npt function for which the flow equation should be derived e.g. {phi,phi} for a bosonic propagator. All derivatives are understood as left derivatives with the rightmost entry acting first unless DoFunInput==True

Options:
DoFunOutput->True/False convert to DoFun-compatible syntax and conventions (op function, vertex definition)
DoFunInput->True/False derivatives in DoFun compatible form (left/right derivatives for afermions/fermions; leftmost derivative acts first)
OffDiagonalRegulators->True/False takes into account off-diagonal regulator terms (i.e. all explicitly specified propagators via interaction terms)
MasterEqn->TrMMA[dtRMMMA,etaMMMA,GMMMA]";

DefineFieldSpecificERGE::usage="Prepares ERGE for call of getAEERGE
Parameter:
list of fields (possibly with sublists of two elements for fermions/ complex bosons for DoFun compatibility) where every entry is expected to be of the form field1[mom,index1,...,indexn] e.g. DefineFieldSpecificERGE[{{psi[mom,color],psib[mom,color]},phi[mom,flav]}]";
getAEERGE::usage="Returns algebraic expression for a given symbolic expression
Parameters:
symbolic_eq: output of doERGE/doEDSE/doEMAGIC
fieldlist: list matching that of the corresponding call used to create the corresponding symbolic expression; every sublist is expected to be of the form {field,index_in_symbolic_eq,...}, where ... denotes all explicit field indices specified in DefineFieldSpecificERGE for that specific field type.
e.g. getAEERGE[myres,{{psi,i1,p1,a1},{psib,i2,p2,a2}}]";

DoFunOutput::usage="Option in doERGE";
DoFunInput::usage="Option in doERGE";
MasterEqn::usage="Option in doERGE";
OffDiagonalRegulators::usage="Option in doERGE";
SetFieldsToZero::usage="Option in doEMAGIC";
DoEDSE::usage="Option in doEMAGIC";
BareVertices::usage="Option in do EDSE";
SetExplicitTrue::usage="adds explicit->True to result of getAEERGE"
mom::usage="The first argument of any field in DefineFieldSpecificERGE always has to be of this type";
deltamom::usage="ERGE notation for momentum deltafunction"

explicitERGE::usage="explicitERGE->True appended to propagators/vertices in ERGE mode of getAEERGE";
(*G::usage="propagator symbol in ERGE";
Gamman::usage="vertex symbol in ERGE";
Gamma0n::usage="bare vertex symbol in ERGE";
dtR::usage="regulator symbol in ERGE";*)


doERGE::firstformscriptfailed="Execution of the first FORM script failed. Aborting.";
doERGE::secondformscriptfailed="Execution of the second FORM script failed. Aborting.";
doERGE::fieldsundefinedinteractions= "The following fields specified in the interactions list were not defined in the fields list: `1`. Aborting.";
doERGE::fieldsundefinedderivatives= "The following fields specified in the derivative list were not defined in the fields list: `1`. Aborting.";
doERGE::fieldspecificationinvalid="The field argument has to contain two sublists, see ?doERGE";
doERGE::sortfields="DoFunInput==True requires a derivative list sorted into fermions, afermions and bosons. Aborting."

doEDSE::noderivativesspecified="DoEDSE requires a non-empty derivative argument. Aborting."

DebuggingModeERGE::usage="DebuggingMode[True/False] prints extra information if set to true.";
DebuggingModeERGE::badarg="DebuggingMode was called with an invalid argument. Argument must be True or False.";

DefineFormExecutableERGE::usage="DefineFormExecutable[path] sets the path the Package looks for the FORM executable.

You can also use tform (a parallel version of FORM) by evaluating \"DefineFormExecutable[tform -wN]\", where you have to replace N with the number of worker threads you want to use.";

DefineFormExecutableERGE::badarg="DefineFormExecutable was called with an invalid argument. Argument must be a string.";

DefineFormExecutableERGE::formnotfound="The specified FORM executable could not be found.";

DefineFormExecutableERGE::cygwin="FORM exited with error code -1073741515. This hints at a problem with your Cygwin installation.";

ERGE::directorynotfound="The package could not locate the package folder in your Applications folder.";


Begin["`Private`"];


packageName="ERGE";
(*determine the FormTracer directory*)
packageDirectory= If[DirectoryQ[FileNameJoin[{$UserBaseDirectory,"Applications",packageName}]],
(*installed in the user directory*)
FileNameJoin[{$UserBaseDirectory,"Applications",packageName}],
If[DirectoryQ[FileNameJoin[{$BaseDirectory,"Applications",packageName}]],
(*installed systemwide*)
FileNameJoin[{$BaseDirectory,"Applications",packageName}],
(*Message[ERGE::directorynotfound];*)
FileNameJoin[{$UserBaseDirectory,"Applications",packageName}]
]
];
defaultFormExecutables={
FileNameJoin[{packageDirectory,If[$OperatingSystem==="Windows","form.exe","form"]}](*has to be the first entry due to InstallFORM*),
"form",(*should work if form lies in any executable path*)
FileNameJoin[{$PathnameSeparator,"usr","bin","form"}],
FileNameJoin[{$PathnameSeparator,"usr","local","bin","form"}],
FileNameJoin[{$PathnameSeparator,"opt","bin","form"}],
FileNameJoin[Flatten@{$UserBaseDirectory,"Applications","FormLink","bin",Switch[$OperatingSystem,"Unix",{"linux64","form"},"MacOSX",{"macosx64","form"},"Windows",{"windows","form.exe"}]}]
};
formExecutable="";(* is set automatically below, can be changed by DefineFormExecutable[path]*) 
formChecked=False;
formInfo="";
debuggingMode=False;
cacheFilesDirectory="ERGECache";
DebuggingModeERGE[yesno_/;BooleanQ[yesno]]:=Module[{},
debuggingMode=yesno;
Print["Debugging mode "<>If[debuggingMode,"enabled","disabled"]<>"."];
];
DebuggingModeERGE[___]:=Message[DebuggingModeERGE::badarg];

checkFormExecutable[quietMode_:False]:=Module[{formProcessResult,formResponse,formExitCode},
(*Don't check whether FORM works if it was already checked.*)
If[formChecked,Return[True(*=formChecked*)]];
(*Check if FORM works*)
formProcessResult=Quiet[RunProcess[{formExecutable,"-v"}]];
formResponse=formProcessResult["StandardOutput"];
formExitCode=formProcessResult["ExitCode"];
formChecked=formExitCode===0;
If[formChecked,
formInfo=StringTrim[StringJoin[Select[StringSplit[formResponse,EndOfLine],Not@StringContainsQ[#,"out of"]&]]];,
formInfo="";
If[Not[quietMode],
Message[DefineFormExecutableERGE::formnotfound];
If[formExitCode===-1073741515&&$OperatingSystem==="Windows",Message[DefineFormExecutableERGE::cygwin];];
];
];
Return[formChecked];
];

(*try to find the FORM executable trying all commands in defaultFormExecutables *)
If[Catch[Do[
formExecutable=tmpFormExecutable;
If[checkFormExecutable[True],Throw[$Success]]
,{tmpFormExecutable,defaultFormExecutables}]]===$Success,
Print["Using "<>formInfo<>"."];,
Print[packageName<>" could not locate the FORM executable. Please install FORM via InstallFORM[].
If FORM is installed on your system, use DefineFormExecutableERGE[pathToExecutable] to specify the path. 
You may also obtain FORM at http://www.nikhef.nl/~form or from https://github.com/vermaseren/form."];
];

DefineFormExecutableERGE[path_String]:=Module[{},
formExecutable=path;
formChecked=False;
If[checkFormExecutable[],Print[formInfo];];
];
DefineFormExecutableERGE[___]:=Message[DefineFormExecutableERGE::badarg];
(*global switch to order fermions/afermions in alphabetical order for DoFun Plotting*)
reorderfermionic=True;
ERGEfieldsspecific={};


stringListJoin[x_]:=Riffle[ToString[#]&/@x,","];


countinteraction[x_,fields_]:=Count[x,#]&/@fields;


countinteractions[interactions_,fields_]:=DeleteDuplicates[countinteraction[#,fields]&/@interactions];


selectinteractionspre[x_]:=DeleteDuplicates[Subsets[x,{Length[x]-2}]];


selectallprops[x_]:=Module[{tmp},tmp=Subsets[x,{2}]; Union[tmp,{#[[2]],#[[1]]}&/@tmp]]; (*all props that might lead to valid vertices after derivative*)


setpropagatorstozero[x_]:="id G("<>ToString[x[[1]]]<>"(ix1?),"<>ToString[x[[2]]]<>"(ix2?))=0;"


converttoformstring[x_]:=StringReplace[ExportString[x/.TrMMA[a__]->Global`TrMMA[a]/.Gamma0[a__]->Global`Gamma0[a],"Text"],{"["->"(","]"->")","MMA"->""}];


derivativestring[x_]:=If[x[[2]]==-1,"-",""]<>StringJoin["Der("<>ToString[Head[#]]<>"(i"<>ToString[#[[1]]]<>"))*"&/@x[[1]]];


fieldargsymasymstring[bosons_,fermions_]:="Function "<>StringJoin[Riffle[Join[Table[ToString[bosons[[i]]]<>"arg(symmetric)",{i,Length[bosons]}],Table[ToString[fermions[[i]]]<>"arg(antisymmetric)",{i,Length[fermions]}]],","]];


gammakeepstring[x_,y_]:="id Gammakeep("<>StringJoin[Riffle[Table[ToString[x[[i]]]<>"(i"<>ToString[i]<>"?)",{i,Length[x]}],","]]<>")="<>ToString[y]<>";\n";


xreplacement[fieldindex_,props_,fields_]:="id once "<>ToString[fields[[fieldindex]]]<>"x(ix0?)="<>StringJoin@@Riffle["G("<>ToString[#[[1]]]<>"(ix0),"<>ToString[#[[2]]]<>"(ix"<>ToString[fieldindex]<>"))*Der("<>ToString[#[[2]]]<>"(ix"<>ToString[fieldindex]<>"))" &/@Select[props,#[[1]]==fields[[fieldindex]]&],"+"]<>"+"<>ToString[fields[[fieldindex]]]<>"(ix0);\nSum ix"<>ToString[fieldindex]<>";"


GMtr[i1_,i2_,fields_,props_,name_,trindex_]:=Table[If[MemberQ[props,{fields[[i]],fields[[j]]}],name[trindex,fields[[i]][i1],fields[[j]][i2]],0],{i,1,Length[fields]},{j,1,Length[fields]}];

GLtr[i1_,i2_,field1_,fields_,props_,name_,trindex_]:=Table[If[MemberQ[props,{field1,fields[[j]]}],name[trindex,field1[i1],fields[[j]][i2]],0],{j,1,Length[fields]}];

GRtr[i1_,i2_,field2_,fields_,props_,name_,trindex_]:=Table[If[MemberQ[props,{fields[[j]],field2}],name[trindex,fields[[j]][i1],field2[i2]],0],{j,1,Length[fields]}];

GammaMtr[extfields_,indices_,interactionscount_,fields_,dualfields_,trindex_]:=Table[If[MemberQ[interactionscount,countinteraction[Join[Head/@extfields,{fields[[i]],fields[[j]]}],fields]],Global`GammaMMA@@Join[{trindex},extfields,{fields[[i]][indices[[1]]],fields[[j]][indices[[2]]]}],0],{i,Length[fields]},{j,Length[fields]}];

etaM[bosonlist_,fieldlist_]:=Table[Table[If[i==j,If[MemberQ[bosonlist,fieldlist[[i]]],1,-1],0],{i,Length[fieldlist]}],{j,Length[fieldlist]}];



toMatrix[x_,i1_,i2_,trindex_,fields_,dualfields_,bosons_,regulatorprops_,fullprops_,interactionscount_]:=Module[{res},
res=If[NumberQ[x],x*IdentityMatrix[Length[fields]],If[x===Global`GM,GMtr[i1,i2,fields,fullprops,Global`GMMA,trindex],If[x===Global`dtRM,GMtr[i1,i2,fields,regulatorprops,Global`dtRMMA,trindex],
If[Head[x]===Global`GL,GLtr[x[[1,1]],i2,Head[x[[1]]],fields,fullprops,Global`GMMA,trindex],
If[Head[x]===Global`GR,GRtr[i1,x[[1,1]],Head[x[[1]]],fields,fullprops,Global`GMMA,trindex],
If[x===Global`etaM,etaM[bosons,fields],
GammaMtr[List@@x,{i1,i2},interactionscount,fields,dualfields,trindex]]]]]]];
Return[res];];


toTrace[x_,fields_,dualfields_,bosons_,defaultprops_,fullprops_,interactionscount_]:=sortTrace[toTraceinternal[List@@x,fields,dualfields,bosons,defaultprops,fullprops,interactionscount]];


indexlist[x_]:=Module[{binarylst,lst},
binarylst=Join[{0},If[#===Global`etaM||NumberQ[#],0,1]&/@x];
lst=Join[Table[1+Plus@@Drop[binarylst,-(Length[binarylst]-i)],{i,1,Length[binarylst]}]];
lst[[Max[Position[binarylst,1]]]]=1;
Return[ToExpression["ix"<>ToString[#]]&/@lst];
]


toTraceinternal[x_,fields_,dualfields_,bosons_,defaultprops_,fullprops_,interactionscount_]:=Module[{indlist,product},
indlist=indexlist[x];
product=Dot@@Table[toMatrix[x[[i]],indlist[[i]],indlist[[i+1]],i,fields,dualfields,bosons,defaultprops,fullprops,interactionscount],{i,1,Length[x]}]//.Dot[a_,b_]->a*b;
If[Head[product]===List,Expand[Tr[product]],Expand[product]]
]


sortTrace[x_]:=If[Head[x]===Plus,Plus@@(sortTraceinternal/@x),sortTraceinternal[x]];


sortTraceinternal[x_]:=Module[{},
If[x==0,Return[0]];
TrMMA@@(If[NumericQ[#],#,Head[#]@@Drop[List@@#,1]]&/@(Sort[List@@x,If[NumericQ[#1]||NumericQ[#2],True,#1[[1]]<#2[[1]]]&]))];


combfactor[interactionscount_]:=Times@@Factorial/@interactionscount


actionfrominteractionsinternal[interactioncount_,fields_]:=Module[{cumulated,lst},
cumulated=Table[{fields[[i]],1+Sum[interactioncount[[j]],{j,i-1}],Sum[interactioncount[[j]],{j,i}]},{i,1,Length[interactioncount]}];
lst=Flatten[(#[[1]]/@Table[ToExpression["iy"<>ToString[i]],{i,#[[2]],#[[3]]}])&/@cumulated];
TrMMA@@Join[{Gamma0@@lst},lst]
]
actionfrominteractions[interactionscount_,fields_]:=Plus@@(1/combfactor[#]*actionfrominteractionsinternal[#,fields]&/@interactionscount)


sign[a_,fermions_]:=Power[-1,Plus@@(Count[a,#]&/@fermions)]
singlederivativeinternal[expr_,field_,i_,fermions_]:=Module[{allfields},
allfields=Select[List@(((expr)/.Times[a__,TrMMA[b__]]->TrMMA[b])/.TrMMA[b__]->b),Head[#]===field&];
If[Length[allfields]==0,Return[0]];
If[MemberQ[fermions,field]==True,expr//.TrMMA[Gamma0[c__],a___,allfields[[1]],b___]:>TrMMA[Gamma0[c],a,b]*sign[Head/@(List@a),fermions]*Length[allfields]/.allfields[[1]]->Head[allfields[[1]]][i],expr/.TrMMA[a___,allfields[[1]],b___]->TrMMA[a,b]*Length[allfields]/.allfields[[1]]->Head[allfields[[1]]][i]]
]
singlederivative[expr_,field_,i_,fermions_]:=If[Head[expr]===Plus,(singlederivativeinternal[#,field,i,fermions]&/@expr),singlederivativeinternal[expr,field,i,fermions]]


toDoFun[x__]:={Head[#],#[[1]]}&/@x;


convertV[expr_,fermions_,afermions_,bosons_]:=Module[{derivs,nfermions,nafermions,fields},
derivs=First/@List@@expr;
nfermions=Plus@@(Count[derivs,#]&/@fermions);
nafermions=Plus@@(Count[derivs,#]&/@afermions);
Return[(-1)*(-1)^(0*nafermions*(nafermions-1)/2)If[reorderfermionic==False,expr,reorderFermionicVertex[expr,fermions,afermions,bosons]]]];


convertToDoFun[y_,fermions_,afermions_,bosons_,extder_]:=If[Length[extder]>2,-1,1]*y/.Global`G[x__]:>DoFun`DoDSERGE`P@@toDoFun[{x}]/.Global`dtR[x__]:>DoFun`DoDSERGE`dR@@toDoFun[{x}]/.Global`Gamman[x__]:>convertV[DoFun`DoDSERGE`V@@toDoFun[{x}],fermions,afermions,bosons]/.Global`Op->DoFun`DoDSERGE`op//.DoFun`DoDSERGE`op[x1___,-DoFun`DoDSERGE`V[x2__],x3___]->-DoFun`DoDSERGE`op[x1,DoFun`DoDSERGE`V[x2],x3]/.Global`Gamma0n[x1_,x2_]:>-convertV[DoFun`DoDSERGE`S@@toDoFun[{x1,x2}],fermions,afermions,bosons]/.Global`Gamma0n[x__]:>convertV[DoFun`DoDSERGE`S@@toDoFun[{x}],fermions,afermions,bosons]//.DoFun`DoDSERGE`op[x1___,-DoFun`DoDSERGE`S[x2__],x3___]->-DoFun`DoDSERGE`op[x1,DoFun`DoDSERGE`S[x2],x3];


convertToERGE[y_]:=y/.Global`G[x__]:>Global`G@@toDoFun[{x}]/.Global`Gamman[x__]:>Global`Gamman@@toDoFun[{x}]/.Global`Gamma0n[x__]:>Global`Gamma0n@@toDoFun[{x}]/.Global`dtR[x__]:>Global`dtR@@toDoFun[{x}]


convertToERGEDerivatives[expr_,fermions_,afermions_,bosons_]:=Module[{exprcheck,derivsorted,nafermions,nfermions,signafermions,signfermions,fermionlst} ,
(*leftmost first in DoFun conventions; assumes sorting*)
exprcheck=Select[expr,MemberQ[Join[fermions,afermions],Head[#]]&];
If[debuggingMode==False&&(Length[SplitBy[exprcheck,MemberQ[fermions,Head[#]]&]]>2||Length[SplitBy[exprcheck,MemberQ[afermions,Head[#]]&]]>2),Message[doERGE::sortfields];Abort[]];
derivsorted=SortBy[Reverse[expr],{MemberQ[fermions,Head[#]]&}];
nafermions=Plus@@(Count[Head/@derivsorted,#]&/@afermions);
nfermions=Plus@@(Count[Head/@derivsorted,#]&/@fermions);
(*converting fermionic right derivatives to left derivatives gives sign (-1)^(nafermions*(nafermions-1)/2))*)
signfermions=Power[(-1),nfermions*(nfermions-1)/2];
(*additional signs for anticommuting across potentially fermionic expression to the left*)
(*fermionlst=Map[If[MemberQ[afermions,#],1,0]&,Table[(Head/@derivsorted)[[i;;-1]],{i,1,Length[derivsorted]}],{2}];*)
signafermions=1;(*Power[-1,Plus@@((1-#[[1]])(nafermions-(Plus@@#))&/@fermionlst)];*)

(*returns {Derivatives,sign}*)
Return[{derivsorted,signfermions*signafermions}]
];


selectFields[l_,x_]:=Last/@Select[l,#[[1]]==x&];
signperm[test_,test2_]:=Power[-1,Plus@@(Mod[#+1,2]&/@Length/@FindPermutation[test,test2][[1]])];

isint[x_]:=StringMatchQ[ToString[x],"iint*"];
(*afermions: iext first ascending then iint ascending
fermions: iint ascending first then iext ascending*)
compareint[x1_,x2_,fermions_]:=If[isint[x1]&&isint[x2],OrderedQ[{x1,x2}],If[isint[x1]&&Not[isint[x2]],fermions,If[isint[x2]&&Not[isint[x1]],Not[fermions],OrderedQ[{x1,x2}]]]];

(*order afermions and fermions according to compareint*)
reorderFermionicVertex[v_,fermions_,afermions_,bosons_]:=Module[{vlist,fields,fieldssorted,indices,indices2,indicesrev,sign},
vlist=List@@v;
fields=DeleteDuplicates[First/@vlist];
(*afermions in reverse order*)
fieldssorted=Join[Intersection[fields,bosons],Reverse[Intersection[fields,afermions]],Intersection[fields,fermions]];
indices=selectFields[vlist,#]&/@fields;
indices2=selectFields[vlist,#]&/@fieldssorted;
indicesrev=Table[If[MemberQ[bosons,fieldssorted[[i]]],indices2[[i]],If[MemberQ[afermions,fieldssorted[[i]]],Sort[indices2[[i]],compareint[#1,#2,False]&],Sort[indices2[[i]],compareint[#1,#2,True]&]]],{i,Length[indices2]}];
signperm[Flatten[indices],Flatten[indicesrev]]*(Head[v]@@Flatten[Table[{fieldssorted[[i]],#}&/@indicesrev[[i]],{i,Length[fields]}],1])
]


DefineFieldSpecificERGE[new_]:=Module[{firstargs},
firstargs=Flatten[List/@Flatten[new][[All,1]]]//DeleteDuplicates;
If[Length[firstargs]!=1||firstargs[[1]]=!=mom,Print["ERROR: The first argument of all fields has to be momentum (mom)."],
ERGEfieldsspecific=new;];];


getAEERGE[diags_,extindices_List,OptionsPattern[{SetExplicitTrue->True,DoFunInput->True}]]:=Module[{diagstmp},
diagstmp=If[Head[diags]===Plus,List@@diags,{diags}];
Return[Plus@@(getAEsinglediagram[#,extindices,ERGEfieldsspecific,OptionValue[SetExplicitTrue],OptionValue[DoFunInput]]&/@diagstmp)]];


tointernal[x_,fieldsspecific_]:=Module[{fieldundef,xpref},
fieldundef=Complement[If[Head[x[[1]]]===List,x[[All,1]],{x[[1]]}],Head/@Flatten[fieldsspecific]]//DeleteDuplicates;
If[Length[fieldundef]>0,Print["ERROR: The following fields remain to be defined via DefineFieldsSpecificERGE:"<>ToString[fieldundef]]; Abort[];];
xpref=Select[Join[{Head[#]},List@@#]&/@Flatten[fieldsspecific],#[[1]]==x[[1]]&][[1,2;;-1]];
Join[x,Table[ToExpression[ToString[xpref[[i]]]<>ToString[i]<>ToString[x[[2]]]],{i,Length[xpref]}]]]


listtofield[x_]:=x[[1]]@@Drop[x,{1}];


replrule[indices_, indicesfull_]:=Module[{},Table[{indices[[i,1]],indices[[i,2]]}->listtofield[Drop[Select[indicesfull,indices[[i,2]]==#[[2]]&][[1]],{2}]],{i,Length[indices]}]]


removedelta[x_,extmom_]:=Module[{symb,repl,xtmp},
If[Length[x]==1,Return[x[[1]]]];(*no delta*)
If[x[[1]]==delta[0],Return[x[[2;;-1]]]];(*delta[0]*)
symb=Complement[Select[Flatten[List@@#&/@List@@x[[1]]]//DeleteDuplicates,Head[#]==Symbol&],extmom];
If[Length[symb]==0,Return[Join[x[[2;;-2]],{x[[1]]*x[[-1]]}]]];(*no dummy momentum available*)
repl=Solve[(List@@x[[1]])[[1]]==0,symb[[1]]][[1]];
Return[x[[2;;-1]]/.repl];
]


getAEsinglediagram[expr_,extindices_,fieldsspecific_,explicittrue_:True,dofuninput_:True]:=Module[{indices,extindicesreduced,extmomenta,internalindicesreduced,indicesfull,exprexplicit,exprexplicitwdeltas,coeff,expr2,res,intmomenta},
(*deal with prefactors*)
If[dofuninput===True,If[Head[expr]===Times,
{coeff,expr2}=expr/.Times[a_/;NumericQ[a],b_]->{a,b},
expr2=expr;
coeff=1;
],
(*ERGE version*)
expr2=Join[Cases[expr,_Rational],Cases[expr,_Integer]];
If[Length[expr2]>1,Print["Malformed expression in getAE."]; Abort[];];
If[Length[expr2]==1,coeff=expr2[[1]];,coeff=1];
expr2=expr/coeff;
];
indices=Flatten[List@@#&/@List@@expr2,1]//DeleteDuplicates;
extindicesreduced={#[[1]],#[[2]]}&/@extindices;
extmomenta=Select[Flatten[List@@#&/@List@@extindices[[All,3]]]//DeleteDuplicates,Head[#]==Symbol&];
internalindicesreduced=Complement[indices,extindicesreduced];
indicesfull=Join[extindices,tointernal[#,fieldsspecific]&/@internalindicesreduced];
exprexplicit=Times@@expr2/.replrule[indices,indicesfull];
exprexplicitwdeltas=Join[delta@@{Plus@@#[[All,1]]}&/@List@@exprexplicit,{exprexplicit}];
res=coeff*Nest[removedelta[#,extmomenta]&,exprexplicitwdeltas,Length[exprexplicitwdeltas]]/.delta[0]->1;
(*for dummy momentum replacement*)
intmomenta=Complement[Cases[Flatten[Apply[List,#]&/@If[dofuninput==True,Select[List@@res,Head[#]==DoFun`DoDSERGE`P||Head[#]==DoFun`DoDSERGE`V||Head[#]==DoFun`DoDSERGE`S||Head[#]==DoFun`DoDSERGE`dR&],Select[List@@res,Head[#]==G||Head[#]==Gamma0||Head[#]==Gamma0n||Head[#]==dtR&]],1][[All,1]],_Symbol,Infinity]//DeleteDuplicates,extmomenta];
res/.If[explicittrue===True,If[dofuninput===True,{DoFun`DoDSERGE`V[x__]->DoFun`DoDSERGE`V[x,DoFun`DoAE`explicit->True],DoFun`DoDSERGE`P[x__]->DoFun`DoDSERGE`P[x,DoFun`DoAE`explicit->True],DoFun`DoDSERGE`S[x__]->DoFun`DoDSERGE`S[x,DoFun`DoAE`explicit->True],DoFun`DoDSERGE`dR[x__]->DoFun`DoDSERGE`dR[x,DoFun`DoAE`explicit->True],delta[x_]->DoFun`DoFR`deltam[x]},{Global`G[x__]->Global`G[x,explicitERGE->True],Global`Gamman[x__]->Global`Gamman[x,explicitERGE->True],Global`Gamma0n[x__]->Global`Gamma0n[x,explicitERGE->True],Global`dtR[x__]->Global`dtR[x,explicitERGE->True],delta[x_]->deltamom[x]}],1->1]/.Table[intmomenta[[i]]->ToExpression["q"<>ToString[i]],{i,Length[intmomenta]}]
];


doEDSE[Fields_List,Interactions_List,Derivatives_List,OptionsPattern[{DoFunInput->True,DoFunOutput->True,BareVertices->{}}]]:=Module[{fieldlist,dualfieldlist,bosonlist,fermionlist,afermionlist,fermionslist,propagatorlist,interactionslist,interactionslistcount,interactionsbarelist,interactionsbarelistcount,expr,derivativesfull,derivativesfullpre},

If[Length[Derivatives]==0,Message[doEDSE::noderivativesspecified];Abort[]];

fieldlist=Flatten[Fields];
dualfieldlist=fieldlist[[#]]&/@PermutationReplace[Range[Length[fieldlist]],Cycles[{#,#+1}&/@Flatten[Position[fieldlist,#]&/@First/@Flatten[Table[Select[Fields[[i]],ListQ[#]&],{i,1,2}],1]]]];
fermionslist=If[Length[Fields[[2]]]>0,Join[Flatten[Fields[[2]]][[1;;-1;;2]],Flatten[Fields[[2]]][[2;;-1;;2]]],{}];
bosonlist=Flatten[Fields[[1]]];
fermionlist=If[Length[Fields[[2]]]>0,Flatten[Fields[[2]]][[1;;-1;;2]],{}];
afermionlist=If[Length[Fields[[2]]]>0,Flatten[Fields[[2]]][[2;;-1;;2]],{}];
propagatorlist=Union[Partition[Riffle[fieldlist,dualfieldlist],2],Flatten[{{#[[1]],#[[2]]},{#[[2]],#[[1]]}}&/@Select[Interactions,Length[#]==2&],1]];

interactionslist=Union[propagatorlist,Interactions];
interactionslistcount=countinteractions[interactionslist,fieldlist];

interactionsbarelist=Union[propagatorlist,If[Length[OptionValue[BareVertices]]==0,Interactions,OptionValue[BareVertices]]];
interactionsbarelistcount=countinteractions[interactionsbarelist,fieldlist];

derivativesfullpre=If[OptionValue[DoFunInput]==True,convertToERGEDerivatives[Table[Derivatives[[i]][i],{i,Length[Derivatives]}],fermionlist,afermionlist,bosonlist],{Table[Derivatives[[Length[Derivatives]-i]][Length[Derivatives]-i],{i,Length[Derivatives]}],1}];
derivativesfull={derivativesfullpre[[1,1;;-2]],derivativesfullpre[[2]]};

expr=singlederivative[actionfrominteractions[interactionsbarelistcount,fieldlist],Head[derivativesfullpre[[1,-1]]],Global`i1,fermionslist]//.TrMMA[a___,x_/;MemberQ[fieldlist,Head[x]],b___]:>TrMMA[a,ToExpression[ToString[Head[x]]~~"x"]@@x,b];

doEMAGIC[Fields,Interactions,expr,derivativesfull,DoEDSE->True,DoFunOutput->OptionValue[DoFunOutput]]
]



doEMAGIC[Fields_List,Interactions_List,Eqn_,Derivativesfull_:{},OptionsPattern[{SetFieldsToZero->True,DoFunOutput->True,DoEDSE->False}]]:=Module[{timeString,formFile1,resFile1,formFile2,resFile2,maxextfields,fieldlist,dualfieldlist,bosonlist,fermionlist,afermionlist,smallerbosons,smallerfermions,smallerafermions,propagatorlist,propagatorlistall,regulatorlist,interactionslist,interactionslistpre,interactionslistcount,nafermions,mastereq,formCode,file,formProcessResult,formresult,formexpr},
If[checkFormExecutable[]==False,Abort[];];
If[Length[Complement[Flatten[Interactions],Flatten[Fields]]]>0,Message[doERGE::fieldsundefinedinteractions,DeleteDuplicates[Complement[Flatten[Interactions],Flatten[Fields]]]];Abort[];];
If[Length[Fields]!=2,Message[doERGE::fieldspecificationinvalid];Abort[]];

timeString=StringJoin@Riffle[Map[If[StringLength[ToString[#]]==1,"0"~~ToString[#],ToString[#]]&,Date[]],"-"];
If[debuggingMode&&Not[DirectoryQ[cacheFilesDirectory]],CreateDirectory[cacheFilesDirectory]];
formFile1=FileNameJoin[{If[debuggingMode,cacheFilesDirectory,$TemporaryDirectory],"runform1_"<>timeString<>".frm"}];
resFile1=FileNameJoin[{If[debuggingMode,cacheFilesDirectory,$TemporaryDirectory],"res1_"<>timeString<>".txt"}];

maxextfields=Max[6,Length[Derivativesfull]+3];(*for setting vertices to zero*)
fieldlist=Flatten[Fields];
dualfieldlist=fieldlist[[#]]&/@PermutationReplace[Range[Length[fieldlist]],Cycles[{#,#+1}&/@Flatten[Position[fieldlist,#]&/@First/@Flatten[Table[Select[Fields[[i]],ListQ[#]&],{i,1,2}],1]]]];
bosonlist=Flatten[Fields[[1]]];
fermionlist=If[Length[Fields[[2]]]>0,Flatten[Fields[[2]]][[1;;-1;;2]],{}];
afermionlist=If[Length[Fields[[2]]]>0,Flatten[Fields[[2]]][[2;;-1;;2]],{}];
smallerbosons=Flatten[Table[Table[{bosonlist[[i]],bosonlist[[j]]},{i,1,j-1}],{j,1,Length[bosonlist]}],1];
smallerfermions=Flatten[Table[Table[{fermionlist[[i]],fermionlist[[j]]},{i,1,j-1}],{j,1,Length[fermionlist]}],1];
smallerafermions=Flatten[Table[Table[{afermionlist[[i]],afermionlist[[j]]},{i,1,j-1}],{j,1,Length[afermionlist]}],1];
propagatorlist=Union[Partition[Riffle[fieldlist,dualfieldlist],2],Flatten[{{#[[1]],#[[2]]},{#[[2]],#[[1]]}}&/@Select[Interactions,Length[#]==2&],1]];
propagatorlistall=Tuples[fieldlist,{2}];(*Union@@(selectallprops[#]&/@Interactions);*)

interactionslist=Select[Interactions,Length[#]>2&];
interactionslistpre=Union@@(selectinteractionspre[#]&/@interactionslist);
interactionslistcount=countinteractions[interactionslist,fieldlist];

formCode="Autodeclare I i;
Autodeclare CFunction f;
Symbol n;
CFunction sign,Gammakeep,delta(symmetric),deltaf(symmetric);
Function Tr,Der,GM,GammaM,etaM,sign,GammaM2,G,GL,GR,Gamma0,end,nfF,Trnc;

********************************************************************************
* all species as CFunctions
Function "<>stringListJoin[fieldlist]<>";
Function "<>stringListJoin[ToString[#]<>"x"&/@fieldlist]<>";

* sets (field-specific)
set boson: "<>stringListJoin[bosonlist]<>";
set fermion: "<>stringListJoin[fermionlist]<>";
set afermion: "<>stringListJoin[afermionlist]<>";

set fermions: "<>stringListJoin[Join[fermionlist,afermionlist]]<>";
set fields: "<>stringListJoin[fieldlist]<>";
set dualfields: "<>stringListJoin[dualfieldlist]<>";

set Gmatrix: GL,GR,GM,GammaM,etaM;
********************************************************************************
*turn off runtime statistics
Off statistics;
.sort
********************************************************************************

Local D="<>If[Length[Derivativesfull]>0,derivativestring[Derivativesfull],""]<>"("<>converttoformstring[Eqn]<>")"<>";
sum iy1,...,iy50;

*insert end markers (rotating Tr if required)
id Tr(?a,Gamma0(?b),?c)=Tr(Gamma0(?b),?c,?a);
id Tr(?a)=Tr(?a,end);

*remove Tr
Repeat; 
id Tr(nfF?(?a),?b)=nfF(?a)*Tr(?b);
id Tr(nfF?,?b)=nfF*Tr(?b);
id Tr()=1;
EndRepeat;

*insert derivative (field-specific)
Repeat;
"<>StringJoin@@Riffle[xreplacement[#,propagatorlistall,fieldlist]&/@Table[i,{i,1,Length[fieldlist]}],"\n"]<>"
EndRepeat;

*apply derivative rules
Repeat;
id Der(?b)*end=0;

*derivative acting on field
Repeat;
id Der(f1?boson(i1?))*f2?fields(i2?)=deltaf(f1,f2)*delta(i1,i2)+f2(i2)*Der(f1(i1));
id Der(f1?fermions(i1?))*f2?fields(i2?)=deltaf(f1,f2)*delta(i1,i2)+sign(f2(i2))*f2(i2)*Der(f1(i1));
id deltaf(f1?,f1?)=1;
id deltaf(f1?,f2?)=0;
EndRepeat;

*remove dummy deltas using dollar variables
if(match(delta(i1?dummyindices_$a1,i2?!dummyindices_$a2))|| match(delta(i1?dummyindices_$a1,i2?dummyindices_$a2)));
Argument;
id $a1=$a2;
Argument;
id $a1=$a2;
Endargument;
Endargument;
endif;
id delta(i1?,i1?)=1;

*explicit G
id Der(f1?boson(i1?))*G(f2?(i2?),f3?(i3?))=-GL(f2(i2))*GammaM(f1(i1))*GR(f3(i3))+G(f2(i2),f3(i3))*Der(f1(i1));
id Der(f1?fermions(i1?))*G(f2?(i2?),f3?(i3?))=-sign(f2(i2))*GL(f2(i2))*etaM*GammaM(f1(i1))*GR(f3(i3))+sign(f2(i2),f3(i3))*G(f2(i2),f3(i3))*Der(f1(i1));

*GR and GL
id Der(f1?boson(i1?))*GL(f2?(i2?))=-GL(f2(i2))*GammaM(f1(i1))*GM+GL(f2(i2))*Der(f1(i1));
id Der(f1?fermions(i1?))*GL(f2?(i2?))=-sign(f2(i2))*GL(f2(i2))*etaM*GammaM(f1(i1))*GM+sign(f2(i2))*GL(f2(i2))*etaM*Der(f1(i1));

id Der(f1?boson(i1?))*GR(f2?(i2?))=-GM*GammaM(f1(i1))*GR(f2(i2))+GR(f2(i2))*Der(f1(i1));
id Der(f1?fermions(i1?))*GR(f2?(i2?))=-etaM*GM*etaM*GammaM(f1(i1))*GR(f2(i2))+sign(f2(i2))*etaM*GR(f2(i2))*Der(f1(i1));

*GM
id Der(f?boson(i1?))*GM=-GM*GammaM(f(i1))*GM+GM*Der(f(i1));
id Der(f?fermions(i1?))*GM=-etaM*GM*etaM*GammaM(f(i1))*GM+etaM*GM*etaM*Der(f(i1));

*GammaM
id Der(f?boson(i1?))*GammaM(?a)=GammaM(f(i1),?a)+GammaM(?a)*Der(f(i1));
id Der(f?fermions(i1?))*GammaM(?a)=GammaM(f(i1),?a)+sign(?a)*etaM*GammaM(?a)*etaM*Der(f(i1));

*etaM
id Der(f1?(i1?))*etaM=etaM*Der(f1(i1));

*Gamma0
*id Der(f?boson(i1?))*Gamma0(?a)=Gamma0(f(i1),?a)+Gamma0(?a)*Der(f(i1));
*id Der(f?fermions(i1?))*Gamma0(?a)=Gamma0(f(i1),?a)+sign(?a)*Gamma0(?a)*Der(f(i1));
id Der(f?(i1?))*Gamma0(?a)=Gamma0(?a)*Der(f(i1));

*sign
id Der(f1?(i1?))*sign(?a)=sign(?a)*Der(f1(i1));

EndRepeat;

Repeat;
id sign(fphi?boson(i?))=1;
id sign(fpsi?fermions(i?))=-1;
id sign(fphi?boson(i?),?a)=sign(?a);
id sign(fpsi?fermions(i?),?a)=-sign(?a);
id sign()=1;
EndRepeat;

* remove etaM squares
repeat id etaM*etaM=1;

* remove end markers
id end=1;
"<>If[OptionValue[SetFieldsToZero]==True,"
********************************************************************************
*set all fields to zero
id f?fields(i1?)=0;
",""]<>"
********************************************************************************
* set non-existing propagators to zero
"<>Riffle[setpropagatorstozero/@Complement[propagatorlistall,propagatorlist],"\n"]<>"
* already set vertices to zero before inserting propagators (field specific)
Repeat;
id GammaM(?a)=Gammakeep(?a)*GammaM2(?a);
EndRepeat;
" <>StringJoin[gammakeepstring[#,1]&/@interactionslistpre]<>"
"<>StringJoin[gammakeepstring[#,0]&/@Table[Table["f"~~ToString[i]~~"?",{i,1,j}],{j,1,maxextfields}]]<>"
id GammaM2(?a)=GammaM(?a);
.sort
*******************************************************************************
*put Tr around everything
id nfF?Gmatrix(?a1)=Trnc(nfF(?a1));
id nfF?Gmatrix=Trnc(nfF);
repeat id Trnc(?a)*Trnc(?b)=Trnc(?a,?b);
id Trnc(?a)=Tr(?a);
.sort
*******************************************************************************
*write to file
Format mathematica;
#write <"<>resFile1<>"> \"(%E)\", D
.end";

file=OpenWrite[formFile1];
WriteString[file,formCode];
Close[file];
(*run FORM*)
formProcessResult=RunProcess[{formExecutable,"-q",formFile1}];
(* check exit code *)
If[formProcessResult["ExitCode"]=!=0,Message[doERGE::firstformscriptfailed];Abort[]];

formresult=ToExpression[StringReplace[ReadString[resFile1],{"_?"->"","\n"->" ","Tr["->"TrMMA["}]]//.Global`TrMMA[x___,a_Integer,y___]->a*Global`TrMMA[x,y]//.Global`TrMMA[x___,Global`G[z__],y___]->Global`G[z]*Global`TrMMA[x,y]//.Global`TrMMA[x___,Global`Gamma0[z__],y___]->Global`Gamma0[z]*Global`TrMMA[x,y]/.Global`TrMMA[]->1;
formexpr=StringReplace[ExportString[formresult/.Global`TrMMA[a__]:>toTrace[Global`TrMMA[a],fieldlist,dualfieldlist,bosonlist,propagatorlist,propagatorlist,interactionslistcount]/.TrMMA[a__]->Global`TrMMA[a],"Text"],{"["->"(","]"->")","MMA"->""}];
If[!debuggingMode,DeleteFile[formFile1]];
If[!debuggingMode,DeleteFile[resFile1]];
formFile2=FileNameJoin[{If[debuggingMode,cacheFilesDirectory,$TemporaryDirectory],"runform2_"<>timeString<>".frm"}];
resFile2=FileNameJoin[{If[debuggingMode,cacheFilesDirectory,$TemporaryDirectory],"res2_"<>timeString<>".txt"}];

formCode="#define EXTFIELDS \""<>ToString[maxextfields]<>"\"
 
Autodeclare I i,N;
Autodeclare CFunction f;
Symbol n,m;
CFunction Tr(cyclic),G,eta,dtR,Gamma,Gamma2,dtR2,G2,current,Gamma0;

set GammadtR: Gamma, dtR, Gamma0;
set GammaG: Gamma, G, Gamma0;
set GammadtRG: Gamma, G, dtR, Gamma0;
set GammadtRG2: Gamma2, G2, dtR2, Gamma0;
********************************************************************************
* all species as CFunctions
CFunction "<>stringListJoin[fieldlist]<>";
"<>fieldargsymasymstring[bosonlist,Join[fermionlist,afermionlist]]<>";

* sets (field-specific)
set boson: "<>stringListJoin[bosonlist]<>";
set fermion: "<>stringListJoin[fermionlist]<>";
set afermion: "<>stringListJoin[afermionlist]<>";

set fermions: "<>stringListJoin[Join[fermionlist,afermionlist]]<>";
set fields: "<>stringListJoin[fieldlist]<>";
set dualfields: "<>stringListJoin[dualfieldlist]<>";

set fieldsargs: "<>stringListJoin[ToString[#]<>"arg"&/@fieldlist]<>";
********************************************************************************
*turn off runtime statistics
Off statistics;
.sort
********************************************************************************
Local D="<>formexpr<>";

***********
*further simplification required...
***********

* remove Tr
chainout Tr;
repeat id Tr(f1?(?a))=f1(?a);
repeat id Tr(n?)=n;

* bring vertices and dtR and propagators in canonical order (field-dep)
Repeat;
* general reordering first bosons then afermions then fermions
id fG?GammadtRG(?a,f1?fermions(i1?),f2?boson(i2?),?b)=fG(?a,f2(i2),f1(i1),?b);
id fG?GammadtRG(?a,f1?fermion(i1?),f2?afermion(i2?),?b)=-fG(?a,f2(i2),f1(i1),?b);
* field-specific ordering of fermion, afermion and boson species among themselves
"<>StringJoin["id fG?GammadtRG(?a,"<>ToString[#[[2]]]<>"(i1?),"<>ToString[#[[1]]]<>"(i2?),?b)=fG(?a,"<>ToString[#[[1]]]<>"(i2),"<>ToString[#[[2]]]<>"(i1),?b);\n"&/@smallerbosons] <>StringJoin["id fG?GammadtRG(?a,"<>ToString[#[[2]]]<>"(i1?),"<>ToString[#[[1]]]<>"(i2?),?b)=-fG(?a,"<>ToString[#[[1]]]<>"(i2),"<>ToString[#[[2]]]<>"(i1),?b);\n"&/@Join[smallerfermions,smallerafermions]]<> "
EndRepeat;

*invert all propagators (DoFun convention)
id G(f1?fermions(i1?),f2?fermions(i2?))=-G(f1(i1),f2(i2));
id G(f1?(i1?),f2?(i2?))=G(f2(i2),f1(i1));

*combine same fields into multiindices
Repeat;
 id fG?GammadtRG(?a,f1?(?c),f1?(?d),?b)=fG(?a,f1(?c,?d),?b);
EndRepeat;

*convert to symmetric/antisymmetric (no wildcards possible afterwards)(field specific)
Argument;
"<>StringJoin["id "<>ToString[#]<>"(?a)="<>ToString[#]<>"arg(?a);\n"&/@fieldlist]<>"
EndArgument;
*pull out signs
Factarg G;
Factarg dtR;
Factarg Gamma;
Factarg Gamma0;
repeat id fG?GammadtRG(?a,-1,?b)=-fG(?a,?b);
.sort
********************************************************************************
*convert vertices back for output (field specific)
Argument;
"<>StringJoin["chainout "<>ToString[#]<>"arg;\n"&/@fieldlist]<>"
EndArgument;
FactArg Gamma;
FactArg Gamma0;
FactArg dtR;
FactArg G;
Argument;
"<>StringJoin["id "<>ToString[#]<>"arg(i1?)="<>ToString[#]<>"(i1);\n"&/@fieldlist]<>"
EndArgument;
"<>If[OptionValue[DoFunOutput]==True,"
*******************************************************************************
*put a Tr around everything for DoFun Compatibility
putinside Tr;
Factarg Tr;
repeat id Tr(n?number_,?a)=n*Tr(?a);
**invert field entries in propagators (cf. DoFun appendix)
Argument;
*id G(f1?fields[n](i1?),f2?fields[m](i2?))=G(dualfields[n](i1),dualfields[m](i2));
EndArgument;
",""]<>"
.sort
*******************************************************************************
*write to file
Format mathematica;
#write <"<>resFile2<>"> \"(%E)\", D
.end
";
file=OpenWrite[formFile2];
WriteString[file,formCode];
Close[file];
(*run FORM*)
formProcessResult=RunProcess[{formExecutable,"-q",formFile2}];
(* check exit code *)
If[formProcessResult["ExitCode"]=!=0,Message[doERGE::secondformscriptfailed]; Abort[]];
(*Import into Mathematica*)
formresult=ToExpression[StringReplace[ReadString[resFile2],{"\n"->" ","Tr["->"Op[","Gamma["->"Gamman[","Gamma0["->"Gamma0n[","G["->"G[","dtR["->"dtR["}]];

If[!debuggingMode,DeleteFile[formFile2]];
If[!debuggingMode,DeleteFile[resFile2]];
If[OptionValue[DoFunOutput]==True,Return[convertToDoFun[formresult,fermionlist,afermionlist,bosonlist,If[OptionValue[DoEDSE]==True,If[Length[Derivativesfull]==0,{0},Join[First[Derivativesfull],{0}]],Derivativesfull]]],Return[convertToERGE[formresult]]];
]



doERGE[Fields_List,Interactions_List,Derivatives_List,OptionsPattern[{DoFunOutput->True,DoFunInput->True,OffDiagonalRegulators->False,MasterEqn->1/2*Global`TrMMA[Global`dtRMMMA,Global`etaMMMA,Global`GMMMA]}]]:=Module[{timeString,formFile1,resFile1,formFile2,resFile2,extfields,fieldlist,dualfieldlist,bosonlist,fermionlist,afermionlist,smallerbosons,smallerfermions,smallerafermions,propagatorlist,regulatorlist,interactionslist,interactionslistpre,interactionslistcount,derivativesfull,nafermions,formCode,file,formProcessResult,formresult,formexpr},
If[checkFormExecutable[]==False,Abort[];];
If[Length[Complement[Flatten[Interactions],Flatten[Fields]]]>0,Message[doERGE::fieldsundefinedinteractions,DeleteDuplicates[Complement[Flatten[Interactions],Flatten[Fields]]]];Abort[];];
If[Length[Complement[Flatten[Derivatives],Flatten[Fields]]]>0,Message[doERGE::fieldsundefinedderivatives,DeleteDuplicates[Complement[Flatten[Derivatives],Flatten[Fields]]]];Abort[];];
If[Length[Fields]!=2,Message[doERGE::fieldspecificationinvalid];Abort[]];

timeString=StringJoin@Riffle[Map[If[StringLength[ToString[#]]==1,"0"~~ToString[#],ToString[#]]&,Date[]],"-"];
If[debuggingMode&&Not[DirectoryQ[cacheFilesDirectory]],CreateDirectory[cacheFilesDirectory]];
formFile1=FileNameJoin[{If[debuggingMode,cacheFilesDirectory,$TemporaryDirectory],"runform1_"<>timeString<>".frm"}];
resFile1=FileNameJoin[{If[debuggingMode,cacheFilesDirectory,$TemporaryDirectory],"res1_"<>timeString<>".txt"}];

extfields=Length[Derivatives];

fieldlist=Flatten[Fields];
dualfieldlist=fieldlist[[#]]&/@PermutationReplace[Range[Length[fieldlist]],Cycles[{#,#+1}&/@Flatten[Position[fieldlist,#]&/@First/@Flatten[Table[Select[Fields[[i]],ListQ[#]&],{i,1,2}],1]]]];
bosonlist=Flatten[Fields[[1]]];
fermionlist=If[Length[Fields[[2]]]>0,Flatten[Fields[[2]]][[1;;-1;;2]],{}];
afermionlist=If[Length[Fields[[2]]]>0,Flatten[Fields[[2]]][[2;;-1;;2]],{}];
smallerbosons=Flatten[Table[Table[{bosonlist[[i]],bosonlist[[j]]},{i,1,j-1}],{j,1,Length[bosonlist]}],1];
smallerfermions=Flatten[Table[Table[{fermionlist[[i]],fermionlist[[j]]},{i,1,j-1}],{j,1,Length[fermionlist]}],1];
smallerafermions=Flatten[Table[Table[{afermionlist[[i]],afermionlist[[j]]},{i,1,j-1}],{j,1,Length[afermionlist]}],1];
propagatorlist=Union[Partition[Riffle[fieldlist,dualfieldlist],2],Flatten[{{#[[1]],#[[2]]},{#[[2]],#[[1]]}}&/@Select[Interactions,Length[#]==2&],1]];
regulatorlist=If[OptionValue[OffDiagonalRegulators],propagatorlist,Partition[Riffle[fieldlist,dualfieldlist],2]];
interactionslist=Select[Interactions,Length[#]>2&];
interactionslistpre=Union@@(selectinteractionspre[#]&/@interactionslist);
interactionslistcount=countinteractions[interactionslist,fieldlist];

derivativesfull=If[OptionValue[DoFunInput]==True,convertToERGEDerivatives[Table[Derivatives[[i]][i],{i,Length[Derivatives]}],fermionlist,afermionlist,bosonlist],{Table[Derivatives[[Length[Derivatives]-i]][Length[Derivatives]-i],{i,Length[Derivatives]}],1}];
nafermions=Plus@@(Count[Derivatives,#]&/@afermionlist);

formCode="#define EXTFIELDS \""<>ToString[extfields]<>"\"
 
Autodeclare I i;
Autodeclare CFunction f;
Symbol n,m;
Function Der,Tr,GM,GammaM,GammaM2,dtRM,etaM,end,nfF,Trnc;
CFunction sign,Gammakeep(symmetric);

set Gmatrix:GM,GammaM,dtRM,etaM;
********************************************************************************
* all species as CFunctions
CFunction "<>stringListJoin[fieldlist]<>";
"<>fieldargsymasymstring[bosonlist,Join[fermionlist,afermionlist]]<>";

* sets (field-specific)
set boson: "<>stringListJoin[bosonlist]<>";
set fermion: "<>stringListJoin[fermionlist]<>";
set afermion: "<>stringListJoin[afermionlist]<>";

set fermions: "<>stringListJoin[Join[fermionlist,afermionlist]]<>";
set fields: "<>stringListJoin[fieldlist]<>";
set dualfields: "<>stringListJoin[dualfieldlist]<>";

set fieldsargs: "<>stringListJoin[ToString[#]<>"arg"&/@fieldlist]<>";
********************************************************************************
*turn off runtime statistics
Off statistics;
.sort
********************************************************************************
Local D="<>If[Length[Derivatives]>0,derivativestring[derivativesfull],""]<>"("<>converttoformstring[OptionValue[MasterEqn]]<>")"<>";
********************************************************************************

*insert end markers (rotating Tr if required)
id Tr(?a,dtRM(?b),?c)=Tr(?c,?a,dtRM(?b));
id Tr(?a)=Tr(?a,end);

*remove Tr
Repeat; 
id Tr(nfF?(?a),?b)=nfF(?a)*Tr(?b);
id Tr(nfF?,?b)=nfF*Tr(?b);
id Tr()=1;
EndRepeat;

********************************************************************************
* carry out derivatives
Repeat;
*GM
id Der(f?boson(i?))*GM=-GM*GammaM(f(i))*GM+GM*Der(f(i));
id Der(f?fermions(i?))*GM=-etaM*GM*etaM*GammaM(f(i))*GM+etaM*GM*etaM*Der(f(i));

*dtR/end
*id Der(f?boson(i?))*dtRM=dtRM*Der(f(i));
*id Der(f?fermions(i?))*dtRM=etaM*dtRM*etaM*Der(f(i));
*id Der(?b)*end=0;
id Der(?b)*dtRM=0;

*GammaM
id Der(f?boson(i?))*GammaM(?a)=GammaM(f(i),?a)+GammaM(?a)*Der(f(i));
id Der(f?fermions(i?))*GammaM(?a)=GammaM(f(i),?a)+sign(?a)*etaM*GammaM(?a)*etaM*Der(f(i));

*etaM
id Der(?a)*etaM=etaM*Der(?a);

*sign
id Der(f1?(i1?))*sign(?a)=sign(?a)*Der(f1(i1));

EndRepeat;

*resolve signs
Repeat;
id sign(fphi?boson(i?))=1;
id sign(fpsi?fermions(i?))=-1;
id sign(fphi?boson(i?),?a)=sign(?a);
id sign(fpsi?fermions(i?),?a)=-sign(?a);
id sign()=1;
EndRepeat;

* remove etaM squares
Repeat;
id etaM*etaM=1;
EndRepeat;

*remove end markers
id end=1;
.sort

********************************************************************************
* already set vertices to zero before inserting propagators (field specific)
Repeat;
id GammaM(?a)=Gammakeep(?a)*GammaM2(?a);
EndRepeat;
" <>StringJoin[gammakeepstring[#,1]&/@interactionslistpre]<>"
"<>StringJoin[gammakeepstring[#,0]&/@Table[Table["f"~~ToString[i]~~"?",{i,1,j}],{j,1,extfields}]]<>"
id GammaM2(?a)=GammaM(?a);
.sort
*******************************************************************************
*put Tr around everything
id nfF?Gmatrix(?a1)=Trnc(nfF(?a1));
id nfF?Gmatrix=Trnc(nfF);
repeat id Trnc(?a)*Trnc(?b)=Trnc(?a,?b);
id Trnc(?a)=Tr(?a);
.sort
*******************************************************************************
*write to file
Format mathematica;
#write <"<>resFile1<>"> \"(%E)\", D
.end
";

file=OpenWrite[formFile1];
WriteString[file,formCode];
Close[file];
(*run FORM*)
formProcessResult=RunProcess[{formExecutable,"-q",formFile1}];
(* check exit code *)
If[formProcessResult["ExitCode"]=!=0,Message[doERGE::firstformscriptfailed];Abort[]];
(*Import into Mathematica*)
formresult=ToExpression[StringReplace[ReadString[resFile1],{"\n"->" ","Tr["->"TrMMA["}]];
formexpr=StringReplace[ExportString[formresult/.Global`TrMMA[a__]:>toTrace[Global`TrMMA[a],fieldlist,dualfieldlist,bosonlist,propagatorlist,regulatorlist,interactionslistcount]/.TrMMA[a__]->Global`TrMMA[a],"Text"],{"["->"(","]"->")","MMA"->""}];
If[!debuggingMode,DeleteFile[formFile1]];
If[!debuggingMode,DeleteFile[resFile1]];
formFile2=FileNameJoin[{If[debuggingMode,cacheFilesDirectory,$TemporaryDirectory],"runform2_"<>timeString<>".frm"}];
resFile2=FileNameJoin[{If[debuggingMode,cacheFilesDirectory,$TemporaryDirectory],"res2_"<>timeString<>".txt"}];

formCode="#define EXTFIELDS \""<>ToString[extfields]<>"\"
 
Autodeclare I i;
Autodeclare CFunction f;
Symbol n,m;
CFunction Tr(cyclic),G,eta,dtR,Gamma,Gamma2,dtR2,G2,current;

set GammadtR: Gamma, dtR;
set GammaG: Gamma, G;
set GammadtRG: Gamma, G, dtR;
set GammadtRG2: Gamma2, G2, dtR2;
********************************************************************************
* all species as CFunctions
CFunction "<>stringListJoin[fieldlist]<>";
"<>fieldargsymasymstring[bosonlist,Join[fermionlist,afermionlist]]<>";

* sets (field-specific)
set boson: "<>stringListJoin[bosonlist]<>";
set fermion: "<>stringListJoin[fermionlist]<>";
set afermion: "<>stringListJoin[afermionlist]<>";

set fermions: "<>stringListJoin[Join[fermionlist,afermionlist]]<>";
set fields: "<>stringListJoin[fieldlist]<>";
set dualfields: "<>stringListJoin[dualfieldlist]<>";

set fieldsargs: "<>stringListJoin[ToString[#]<>"arg"&/@fieldlist]<>";
********************************************************************************
*turn off runtime statistics
Off statistics;
.sort
********************************************************************************
Local D="<>formexpr<>";

id Tr(n?number_,?a)=n*Tr(?a);
********************************************************************************
*for the case of no derivatives
id Tr(G(f1?(ix1?),f2?(ix2?)),dtR(f3?fermion(ix2?),f4?afermion(ix1?)))=Tr(G(f2(ix1),f1(ix2)),dtR(f4(ix2),f3(ix1)));

*order Tr such that smallest ext ind is reached first
#do iext=1,`EXTFIELDS'
*reverse Tr only if smallest ext index is found in the other direction 
*or fermionic tadpole with regulator not in canonical order
if(match(Tr(?a1,Gamma(?a2,f1?(i`iext'),?a3),G(?a4),dtR(f2?(i2?),f3?(i3?)),G(?a6),Gamma(?a7)))||match(Tr(G(?a),dtR(f3?fermion(ix2?),f4?afermion(ix3?)),G(?b),Gamma(?c)))||match(Tr(G(?a),Gamma(?c),G(?b),dtR(f3?fermion(ix2?),f4?afermion(ix3?)))));
Transform,Tr,reverse(1,last);
Argument;
id fG?GammadtRG(?a,f1?fermions(i1?),f2?fermions(i2?))=-fG(?a,f2(i2),f1(i1));
id fG?GammadtRG[n](?a,f1?boson(i1?),f2?fermions(i2?))=GammadtRG2[n](?a,f2(i2),f1(i1));
id fG?GammadtRG[n](?a,f1?fermions(i1?),f2?boson(i2?))=GammadtRG2[n](?a,f2(i2),f1(i1));
id fG?GammadtRG(?a,f1?boson(i1?),f2?boson(i2?))=fG(?a,f2(i2),f1(i1));
Endargument;
Factarg Tr;
repeat id Tr(n?number_,?a)=n*Tr(?a);
id Tr(?d,dtR(?a),G(?b),Gamma(?c))=Tr(?d,dtR(?a),G(?b),Gamma2(?c));
else;
id Tr(?a1,dtR(?a2),G(?a3),Gamma(?a4,f1?(i`iext'),?a5))=Tr(?a1,dtR(?a2),G(?a3),Gamma2(?a4,f1(i`iext'),?a5));
endif;
#enddo

argument;
id Gamma2(?a)=Gamma(?a);
id dtR(?a)=current(dtR(?a));
endargument;

*rename all dummy indices to iint
#do iext=1,{2*`EXTFIELDS'+2}
id  Tr(?a,current(fG1?(?b,f1?(i1?),f2?(i2?))),fG2?(?c,f3?(i2?),f4?(i3?)))=Tr(?a,fG1(?b,f1(i1),f2(iint`iext')),current(fG2(?c,f3(iint`iext'),f4(i3))));
id Tr(?a,current(dtR(?b)))=Tr(?a,dtR(?b));
#enddo

********************************************************************************
********************************************************************************
* remove Tr
chainout Tr;
repeat id Tr(f1?(?a))=f1(?a);

* bring vertices and dtR and propagators in canonical order (field-dep)
Repeat;
* general reordering first bosons then afermions then fermions
id fG?GammadtRG(?a,f1?fermions(i1?),f2?boson(i2?),?b)=fG(?a,f2(i2),f1(i1),?b);
id fG?GammadtRG(?a,f1?fermion(i1?),f2?afermion(i2?),?b)=-fG(?a,f2(i2),f1(i1),?b);
* field-specific ordering of fermion, afermion and boson species among themselves
"<>StringJoin["id fG?GammadtRG(?a,"<>ToString[#[[2]]]<>"(i1?),"<>ToString[#[[1]]]<>"(i2?),?b)=fG(?a,"<>ToString[#[[1]]]<>"(i2),"<>ToString[#[[2]]]<>"(i1),?b);\n"&/@smallerbosons] <>StringJoin["id fG?GammadtRG(?a,"<>ToString[#[[2]]]<>"(i1?),"<>ToString[#[[1]]]<>"(i2?),?b)=-fG(?a,"<>ToString[#[[1]]]<>"(i2),"<>ToString[#[[2]]]<>"(i1),?b);\n"&/@Join[smallerfermions,smallerafermions]]<> "
EndRepeat;

*invert all propagators (canonical ordering in DoFun convention)
id G(f1?fermions(i1?),f2?fermions(i2?))=-G(f1(i1),f2(i2));
id G(f1?(i1?),f2?(i2?))=G(f2(i2),f1(i1));

*combine same fields into multiindices
Repeat;
 id fG?GammadtRG(?a,f1?(?c),f1?(?d),?b)=fG(?a,f1(?c,?d),?b);
EndRepeat;

*convert to symmetric/antisymmetric (no wildcards possible afterwards)(field specific)
Argument;
"<>StringJoin["id "<>ToString[#]<>"(?a)="<>ToString[#]<>"arg(?a);\n"&/@fieldlist]<>"
EndArgument;
*pull out signs
Factarg G;
Factarg dtR;
Factarg Gamma;
repeat id fG?GammadtRG(?a,-1,?b)=-fG(?a,?b);
.sort
********************************************************************************
*convert vertices back for output (field specific)
Argument;
"<>StringJoin["chainout "<>ToString[#]<>"arg;\n"&/@fieldlist]<>"
EndArgument;
FactArg Gamma;
FactArg dtR;
FactArg G;
Argument;
"<>StringJoin["id "<>ToString[#]<>"arg(i1?)="<>ToString[#]<>"(i1);\n"&/@fieldlist]<>"
EndArgument;
"<>If[OptionValue[DoFunOutput]==True,"
*******************************************************************************
*put a Tr around everything for DoFun Compatibility
putinside Tr;
Factarg Tr;
repeat id Tr(n?number_,?a)=n*Tr(?a);
**invert field entries in propagators (cf. DoFun appendix)
Argument;
*id G(f1?fields[n](i1?),f2?fields[m](i2?))=G(dualfields[n](i1),dualfields[m](i2));
EndArgument;
",""]<>"
.sort
*******************************************************************************
*write to file
Format mathematica;
#write <"<>resFile2<>"> \"(%E)\", D
.end
";
file=OpenWrite[formFile2];
WriteString[file,formCode];
Close[file];
(*run FORM*)
formProcessResult=RunProcess[{formExecutable,"-q",formFile2}];
(* check exit code *)
If[formProcessResult["ExitCode"]=!=0,Message[doERGE::secondformscriptfailed]; Abort[]];
(*Import into Mathematica*)
formresult=ToExpression[StringReplace[ReadString[resFile2],{"\n"->" ","Tr["->"Op[","Gamma["->"Gamman[","G["->"G[","dtR["->"dtR["}]];

If[!debuggingMode,DeleteFile[formFile2]];
If[!debuggingMode,DeleteFile[resFile2]];
If[OptionValue[DoFunOutput]==True,Return[convertToDoFun[formresult,fermionlist,afermionlist,bosonlist,Derivatives]],Return[convertToERGE[formresult]]];
];


End[];
Protect@@Names["ERGE`*"];
EndPackage[];
